/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

package com.facebook.marianatrench.integrationtests;

public class MainActivity {
  Event mEvent;

  protected void call() {
    // This test is run using the legacy_dx as dexer.
    // With dx, the bytecode generated here is:
    // L1 Block 0 (entry):
    // L2   IOPCODE_LOAD_PARAM_OBJECT v2 // this: MainActivity
    // L3   NEW_INSTANCE LMainActivity$Event;
    // L4   IOPCODE_MOVE_RESULT_PSEUDO_OBJECT v0
    // L5   CONST v1, 0
    // L6   INVOKE_DIRECT v0, v2, v1, LMainActivity$Event;.<init>:(LMainActivity;LMainActivity$1;)V
    // L7   IPUT_OBJECT v0, v2, LMainActivity;.mEvent:LMainActivity$Event;
    // L8   IGET_OBJECT v2, MainActivity;.mEvent:LMainActivity$Event;
    // L9   IOPCODE_MOVE_RESULT_PSEUDO_OBJECT v1
    // L10  INVOKE_STATIC LOrigin;.source:()Ljava/lang/Object;
    // L11  MOVE_RESULT_OBJECT v0
    // L12  CHECK_CAST v0, Ljava/lang/String;
    // L13  IOPCODE_MOVE_RESULT_PSEUDO_OBJECT v0
    // L14  IPUT_OBJECT v0, v1, LMainActivity$Event;.tainted:Ljava/lang/String;
    // L15  RETURN_VOID
    //
    // Here,
    // - In L8 and L9, the forward alias analysis will assign the memory location
    //   {`FieldMemoryLocation(ThisParameterMemoryLocation, `mEvent`)`} to register v1.
    // - Then, iput instruction at L14 will taint the memory location:
    //   {FieldMemoryLocation(FieldMemoryLocation(ThisParameterMemoryLocation, `mEvent`),
    //   `tainted`)}
    //
    // Differences with D8:
    // The bytecode generated by d8 optimizes out the instructions in lines L8 and L9 above.
    // With d8, the bytecode generated here is:
    // L'1 Block 0 (entry):
    // L'2   IOPCODE_LOAD_PARAM_OBJECT v2
    // L'3   NEW_INSTANCE LMainActivity$Event;
    // L'4   IOPCODE_MOVE_RESULT_PSEUDO_OBJECT v0
    // L'5   CONST v1, 0
    // L'6   INVOKE_DIRECT v0, v2, v1, LMainActivity$Event;.<init>:(LMainActivity;LMainActivity$1;)V
    // L'7   IPUT_OBJECT v0, v2, LMainActivity;.mEvent:LMainActivity$Event;
    // L'8   INVOKE_STATIC LOrigin;.source:()Ljava/lang/Object;
    // L'9   MOVE_RESULT_OBJECT v1
    // L'10  CHECK_CAST v1, Ljava/lang/String;
    // L'11  IOPCODE_MOVE_RESULT_PSEUDO_OBJECT v1
    // L'12  IPUT_OBJECT v1, v0, LMainActivity$Event;.tainted:Ljava/lang/String;
    // L'13  RETURN_VOID
    //
    // This means that the equivalent iput instruction of L14, which is L'12:
    // - IPUT_OBJECT v1, v0, LMainActivity$Event;.tainted:Ljava/lang/String;
    // - Here, the register v0 still points to the memory location:
    //   FieldMemoryLocation(InstructionMemoryLocation(`NEW_INSTANCE LMainActivity$Event;`),
    //   `tainted`)
    // - Since the ThisParameterMemoryLocation.mEvent.tainted is no longer tainted,
    //   we no longer infer the generation on Argument(0).mEvent.tainted and lose the flow.
    mEvent = new Event();
    mEvent.tainted = (String) Origin.source();
    return;
  }

  protected void onCreate() {
    this.call();
    String data = this.noCode();
    Origin.sink(data);
  }

  // in models.json this method is mocked as not having code (skip-analysis and TITO)
  // to avoid build failures it is implemented here
  public String noCode() {
    return "";
  }

  private class Event {
    public String tainted;
    public String hardcoded;
  }
}
